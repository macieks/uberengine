<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Assimp: Usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="usage">Usage </a></h1><h2><a class="anchor" name="access_cpp">
Access by C++ class interface</a></h2>
The ASSIMP library can be accessed by both a class or flat function interface. The C++ class interface is the preferred way of interaction: you create an instance of class <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open...">Assimp::Importer</a>, maybe adjust some settings of it and then call <a class="el" href="class_assimp_1_1_importer.html#174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">Assimp::Importer::ReadFile()</a>. The class will read the files and process its data, handing back the imported data as a pointer to an <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a> to you. You can now extract the data you need from the file. The importer manages all the resources for itsself. If the importer is destroyed, all the data that was created/read by it will be destroyed, too. So the easiest way to use the Importer is to create an instance locally, use its results and then simply let it go out of scope.<p>
C++ example: <div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="assimp_8hpp.html" title="Defines the C++-API to the Open Asset Import Library.">assimp.hpp</a>&gt;</span>      <span class="comment">// C++ importer interface</span>
<span class="preprocessor">#include &lt;<a class="code" href="ai_scene_8h.html" title="Defines the data structures in which the imported scene is returned.">aiScene.h</a>&gt;</span>       <span class="comment">// Output data structure</span>
<span class="preprocessor">#include &lt;<a class="code" href="ai_post_process_8h.html" title="Definitions for import post processing steps.">aiPostProcess.h</a>&gt;</span> <span class="comment">// Post processing flags</span>

<span class="keywordtype">bool</span> DoTheImportThing( <span class="keyword">const</span> std::string&amp; pFile)
{
  <span class="comment">// Create an instance of the Importer class</span>
  <a class="code" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open...">Assimp::Importer</a> importer;

  <span class="comment">// And have it read the given file with some example postprocessing</span>
  <span class="comment">// Usually - if speed is not the most important aspect for you - you'll </span>
  <span class="comment">// propably to request more postprocessing than we do in this example.</span>
  <span class="keyword">const</span> <a class="code" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a>* scene = importer.<a class="code" href="class_assimp_1_1_importer.html#174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile</a>( pFile, 
        <a class="code" href="ai_post_process_8h.html#64795260b95f5a4b3f3dc1be4f52e4108857a0e30688127a82c7b8939958c6dc">aiProcess_CalcTangentSpace</a>       | 
        <a class="code" href="ai_post_process_8h.html#64795260b95f5a4b3f3dc1be4f52e4109c3de834f0307f31fa2b1b6d05dd592b">aiProcess_Triangulate</a>            |
        <a class="code" href="ai_post_process_8h.html#64795260b95f5a4b3f3dc1be4f52e410444a6c9d8b63e6dc9e1e2e1edd3cbcd4">aiProcess_JoinIdenticalVertices</a>  |
        <a class="code" href="ai_post_process_8h.html#64795260b95f5a4b3f3dc1be4f52e410b4484f73635d633cd79973bac1431ed6">aiProcess_SortByPType</a>);
  
  <span class="comment">// If the import failed, report it</span>
  <span class="keywordflow">if</span>( !scene)
  {
    DoTheErrorLogging( importer.<a class="code" href="class_assimp_1_1_importer.html#23bab5ba8cb9b6886c690a610766668b" title="Returns an error description of an error that occurred in ReadFile().">GetErrorString</a>());
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
  }

  <span class="comment">// Now we can access the file's contents. </span>
  DoTheSceneProcessing( scene);

  <span class="comment">// We're done. Everything will be cleaned up by the importer destructor</span>
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div><p>
What exactly is read from the files and how you interpret it is described at the <a class="el" href="data.html">Data Structures</a> page.  The post processing steps that the ASSIMP library can apply to the imported data are listed at <a class="el" href="ai_post_process_8h.html#64795260b95f5a4b3f3dc1be4f52e410" title="Defines the flags for all possible post processing steps.">aiPostProcessSteps</a>. See the pp Post proccessing page for more details.<p>
Note that the <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a> data structure returned is declared 'const'. Yes, you can get rid of these 5 letters with a simple cast. Yes, you may do that. No, it's not recommended (and it's suicide in DLL builds if you try to use new or delete on any of the arrays in the scene).<h2><a class="anchor" name="access_c">
Access by plain-c function interface</a></h2>
The plain function interface is just as simple, but requires you to manually call the clean-up after you're done with the imported data. To start the import process, call <a class="el" href="assimp_8h.html#09fe8ba0c8e91bf04b4c29556be53b6d" title="Reads the given file and returns its content.">aiImportFile()</a> with the filename in question and the desired postprocessing flags like above. If the call is successful, an <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a> pointer with the imported data is handed back to you. When you're done with the extraction of the data you're interested in, call <a class="el" href="assimp_8h.html#00a8db599403d4972ce70d97b9219080" title="Releases all resources associated with the given import process.">aiReleaseImport()</a> on the imported scene to clean up all resources associated with the import.<p>
C example: <div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="assimp_8h.html" title="Defines the C-API to the Open Asset Import Library.">assimp.h</a>&gt;</span>        <span class="comment">// Plain-C interface</span>
<span class="preprocessor">#include &lt;<a class="code" href="ai_scene_8h.html" title="Defines the data structures in which the imported scene is returned.">aiScene.h</a>&gt;</span>       <span class="comment">// Output data structure</span>
<span class="preprocessor">#include &lt;<a class="code" href="ai_post_process_8h.html" title="Definitions for import post processing steps.">aiPostProcess.h</a>&gt;</span> <span class="comment">// Post processing flags</span>

<span class="keywordtype">bool</span> DoTheImportThing( <span class="keyword">const</span> <span class="keywordtype">char</span>* pFile)
{
  <span class="comment">// Start the import on the given file with some example postprocessing</span>
  <span class="comment">// Usually - if speed is not the most important aspect for you - you'll t</span>
  <span class="comment">// probably to request more postprocessing than we do in this example.</span>
  <span class="keyword">const</span> <a class="code" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a>* scene = <a class="code" href="assimp_8h.html#09fe8ba0c8e91bf04b4c29556be53b6d" title="Reads the given file and returns its content.">aiImportFile</a>( pFile, 
    <a class="code" href="ai_post_process_8h.html#64795260b95f5a4b3f3dc1be4f52e4108857a0e30688127a82c7b8939958c6dc">aiProcess_CalcTangentSpace</a>       | 
        <a class="code" href="ai_post_process_8h.html#64795260b95f5a4b3f3dc1be4f52e4109c3de834f0307f31fa2b1b6d05dd592b">aiProcess_Triangulate</a>            |
        <a class="code" href="ai_post_process_8h.html#64795260b95f5a4b3f3dc1be4f52e410444a6c9d8b63e6dc9e1e2e1edd3cbcd4">aiProcess_JoinIdenticalVertices</a>  |
        <a class="code" href="ai_post_process_8h.html#64795260b95f5a4b3f3dc1be4f52e410b4484f73635d633cd79973bac1431ed6">aiProcess_SortByPType</a>);

  <span class="comment">// If the import failed, report it</span>
  <span class="keywordflow">if</span>( !scene)
  {
    DoTheErrorLogging( <a class="code" href="assimp_8h.html#be72551b74cc4bc3c49349ce3014bc9b" title="Returns the error text of the last failed import process.">aiGetErrorString</a>());
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
  }

  <span class="comment">// Now we can access the file's contents</span>
  DoTheSceneProcessing( scene);

  <span class="comment">// We're done. Release all resources associated with this import</span>
  <a class="code" href="assimp_8h.html#00a8db599403d4972ce70d97b9219080" title="Releases all resources associated with the given import process.">aiReleaseImport</a>( scene);
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div><h2><a class="anchor" name="custom_io">
Using custom IO logic with the C++ class interface</a></h2>
The ASSIMP library needs to access files internally. This of course applies to the file you want to read, but also to additional files in the same folder for certain file formats. By default, standard C/C++ IO logic is used to access these files. If your application works in a special environment where custom logic is needed to access the specified files, you have to supply custom implementations of IOStream and IOSystem. A shortened example might look like this:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="_i_o_stream_8h.html" title="File I/O wrappers for C++.">IOStream.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="_i_o_system_8h.html" title="File system wrapper for C++.">IOSystem.h</a>&gt;</span>

<span class="comment">// My own implementation of IOStream</span>
<span class="keyword">class </span>MyIOStream : <span class="keyword">public</span> ASSIMP::IOStream
{
  <span class="keyword">friend</span> <span class="keyword">class </span>MyIOSystem;

<span class="keyword">protected</span>:
  <span class="comment">// Constructor protected for private usage by MyIOSystem</span>
  MyIOStream(<span class="keywordtype">void</span>);

<span class="keyword">public</span>:
  ~MyIOStream(<span class="keywordtype">void</span>);
  <span class="keywordtype">size_t</span> Read( <span class="keywordtype">void</span>* pvBuffer, <span class="keywordtype">size_t</span> pSize, <span class="keywordtype">size_t</span> pCount) { ... }
  <span class="keywordtype">size_t</span> Write( <span class="keyword">const</span> <span class="keywordtype">void</span>* pvBuffer, <span class="keywordtype">size_t</span> pSize, <span class="keywordtype">size_t</span> pCount) { ... }
  aiReturn Seek( <span class="keywordtype">size_t</span> pOffset, aiOrigin pOrigin) { ... }
  <span class="keywordtype">size_t</span> Tell()<span class="keyword"> const </span>{ ... }
  <span class="keywordtype">size_t</span> FileSize()<span class="keyword"> const </span>{ ... }
  <span class="keywordtype">void</span> Flush () { ... }
};

<span class="comment">// Fisher Price - My First Filesystem</span>
<span class="keyword">class </span>MyIOSystem : <span class="keyword">public</span> ASSIMP::IOSystem
{
  MyIOSystem() { ... }
  ~MyIOSystem() { ... }

  <span class="comment">// Check whether a specific file exists</span>
  <span class="keywordtype">bool</span> Exists( <span class="keyword">const</span> std::string&amp; pFile)<span class="keyword"> const </span>{
    .. 
  }

  <span class="comment">// Get the path delimiter character we'd like to see</span>
  <span class="keywordtype">char</span> GetOsSeparator()<span class="keyword"> const </span>{ 
    <span class="keywordflow">return</span> <span class="charliteral">'/'</span>; 
  }

  <span class="comment">// ... and finally a method to open a custom stream</span>
  IOStream* Open( <span class="keyword">const</span> std::string&amp; pFile, <span class="keyword">const</span> std::string&amp; pMode) {
        <span class="keywordflow">return</span> <span class="keyword">new</span> MyIOStream( ... ); 
  }

  <span class="keywordtype">void</span> Close( IOStream* pFile) { <span class="keyword">delete</span> pFile; }
};
</pre></div><p>
Now that your IO system is implemented, supply an instance of it to the Importer object by calling <a class="el" href="class_assimp_1_1_importer.html#1161f46318af18bb86dfe0fc3edea4df" title="Supplies a custom IO handler to the importer to use to open and access files.">Assimp::Importer::SetIOHandler()</a>.<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> DoTheImportThing( <span class="keyword">const</span> std::string&amp; pFile)
{
  <a class="code" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open...">Assimp::Importer</a> importer;
  <span class="comment">// put my custom IO handling in place</span>
  importer.<a class="code" href="class_assimp_1_1_importer.html#1161f46318af18bb86dfe0fc3edea4df" title="Supplies a custom IO handler to the importer to use to open and access files.">SetIOHandler</a>( <span class="keyword">new</span> MyIOSystem());

  <span class="comment">// the import process will now use this implementation to access any file</span>
  importer.<a class="code" href="class_assimp_1_1_importer.html#174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile</a>( pFile, SomeFlag | SomeOtherFlag);
}
</pre></div><h2><a class="anchor" name="custom_io_c">
Using custom IO logic with the plain-c function interface</a></h2>
The C interface also provides a way to override the file system. Control is not as fine-grained as for C++ although surely enough for almost any purpose. The process is simple:<p>
<ul>
<li>
Include <a class="el" href="ai_file_i_o_8h.html" title="Defines generic C routines to access memory-mapped files.">aiFileIO.h</a> </li>
<li>
Fill an <a class="el" href="structai_file_i_o.html" title="C-API: File system callbacks.">aiFileIO</a> structure with custom file system callbacks (they're self-explanatory as they work similar to the CRT's fXXX functions) </li>
<li>
.. and pass it as last parameter to <a class="el" href="assimp_8hpp.html#590ab8b19137bc0fe4af1f404334beeb">aiImportFileEx</a> </li>
</ul>
<h2><a class="anchor" name="threadsafety">
Thread-safety and internal multi-threading</a></h2>
The ASSIMP library can be accessed by multiple threads simultaneously, as long as the following prerequisites are fulfilled: <ul>
<li>
When using the C++-API make sure you create a new Importer instance for each thread. Constructing instances of Importer is expensive, so it might be a good idea to let every thread maintain its own thread-local instance (use it to load as many models as you want). </li>
<li>
The C-API is threadsafe as long as AI_C_THREADSAFE is defined. That's the default.  </li>
<li>
When supplying custom IO logic, make sure your underyling implementation is thead-safe. </li>
<li>
Custom log streams or logger replacements have to be thread-safe, too. </li>
</ul>
<p>
See the <a class="el" href="install.html#assimp_st">Single-threaded build</a> section  to learn how to build a lightweight variant of ASSIMP which is not thread-safe and does not utilize multiple threads for loading.<h2><a class="anchor" name="logging">
Logging</a></h2>
The ASSIMP library provides an easy mechanism to log messages. For instance if you want to check the state of your import and you just want to see, after which preprocessing step the import-process was aborted you can take a look into the log. Per default the ASSIMP-library provides a default log implementation, where you can log your user specific message by calling it as a singleton with the requested logging-type. To see how this works take a look to this:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>Assimp;

<span class="comment">// Create a logger instance </span>
DefaultLogger::create(<span class="stringliteral">""</span>,Logger::VERBOSE);

<span class="comment">// Now I am ready for logging my stuff</span>
DefaultLogger::get()-&gt;info(<span class="stringliteral">"this is my info-call"</span>);

<span class="comment">// Kill it after the work is done</span>
DefaultLogger::kill();
</pre></div><p>
At first you have to create the default-logger-instance (create). Now you are ready to rock and can log a little bit around. After that you should kill it to release the singleton instance.<p>
If you want to integrate the ASSIMP-log into your own GUI it my be helpful to have a mechanism writing the logs into your own log windows. The logger interface provides this by implementing an interface called LogStream. You can attach and detach this log stream to the default-logger instance or any implementation derived from Logger. Just derivate your own logger from the abstract base class LogStream and overwrite the write-method:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Example stream</span>
<span class="keyword">class </span>myStream :
        <span class="keyword">public</span> LogStream
{
<span class="keyword">public</span>:
        <span class="comment">// Constructor</span>
        myStream()
        {
                <span class="comment">// empty</span>
        }
        
        <span class="comment">// Destructor</span>
        ~myStream()
        {
                <span class="comment">// empty</span>
        }

        <span class="comment">// Write womethink using your own functionality</span>
        <span class="keywordtype">void</span> write(<span class="keyword">const</span> <span class="keywordtype">char</span>* message)
        {
                ::printf(<span class="stringliteral">"%s\n"</span>, message);
        }
};

<span class="comment">// Select the kinds of messages you want to receive on this log stream</span>
<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> severity = Logger::DEBUGGING|Logger::INFO|Logger::ERR|Logger::WARN;

<span class="comment">// Attaching it to the default logger</span>
<a class="code" href="class_assimp_1_1_default_logger.html#7d0a53f2db66945ade30094330a77ba4" title="Getter for singleton instance.">Assimp::DefaultLogger::get</a>()-&gt;attachStream( <span class="keyword">new</span> myStream(), severity );
</pre></div><p>
The severity level controls the kind of message which will be written into the attached stream. If you just want to log errors and warnings set the warn and error severity flag for those severities. It is also possible to remove a self defined logstream from an error severity by detaching it with the severity flag set:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> severity = 0;
severity |= Logger::DEBUGGING;

<span class="comment">// Detach debug messages from you self defined stream</span>
<a class="code" href="class_assimp_1_1_default_logger.html#7d0a53f2db66945ade30094330a77ba4" title="Getter for singleton instance.">Assimp::DefaultLogger::get</a>()-&gt;attachStream( <span class="keyword">new</span> myStream(), severity );
</pre></div><p>
If you want to implement your own logger just derive from the abstract base class Logger and overwrite the methods debug, info, warn and error.<p>
If you want to see the debug-messages in a debug-configured build, the Logger-interface provides a logging-severity. You can set it calling the following method:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="class_assimp_1_1_default_logger.html#7d0a53f2db66945ade30094330a77ba4" title="Getter for singleton instance.">Assimp::DefaultLogger::get</a>()-&gt;setLogSeverity( LogSeverity log_severity );
</pre></div><p>
The normal logging severity supports just the basic stuff like, info, warnings and errors. In the verbose level very fine-grained debug messages will be logged, too. Note that this kind kind of logging might decrease import performance. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 17 18:41:24 2010 for Assimp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
