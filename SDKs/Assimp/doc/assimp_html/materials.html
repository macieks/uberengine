<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Assimp: Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="materials">Material System </a></h1><h2><a class="anchor" name="General">
General</a></h2>
All materials are stored in an array of <a class="el" href="structai_material.html" title="Data structure for a material.">aiMaterial</a> inside the <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a>.<p>
Each <a class="el" href="structai_mesh.html" title="A mesh represents a geometry or model with a single material.">aiMesh</a> refers to one material by its index in the array. Due to the vastly diverging definitions and usages of material parameters there is no hard definition of a material structure. Instead a material is defined by a set of properties accessible by their names. Have a look at <a class="el" href="ai_material_8h.html" title="Defines the material system of the library.">aiMaterial.h</a> to see what types of properties are defined. In this file there are also various functions defined to test for the presence of certain properties in a material and retrieve their values.<h2><a class="anchor" name="mat_tex">
Textures</a></h2>
Textures are organized in stacks, each stack being evaluated independently. The final color value from a particular texture stack is used in the shading equation. For example, the computed color value of the diffuse texture stack (aiTextureType_DIFFUSE) is multipled with the amount of incoming diffuse light to obtain the final diffuse color of a pixel.<p>
<div class="fragment"><pre class="fragment"> Stack                               Resulting equation

------------------------
| Constant base color  |             color
------------------------ 
| Blend operation 0    |             +
------------------------
| Strength factor 0    |             0.25*
------------------------
| Texture 0            |             texture_0
------------------------ 
| Blend operation 1    |             *
------------------------
| Strength factor 1    |             1.0*
------------------------
| Texture 1            |             texture_1
------------------------
  ...                                ...
</pre></div><h2><a class="anchor" name="keys">
Constants</a></h2>
All material key constants start with 'AI_MATKEY' (it's an ugly macro for historical reasons, don't ask).<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<th>Name </th><th>Data Type </th><th>Default Value </th><th>Meaning </th><th>Notes  </th></tr>
<tr>
<td><code>NAME</code> </td><td><a class="el" href="structai_string.html" title="Represents an UTF-8 string, zero byte terminated.">aiString</a> </td><td>n/a </td><td>The name of the material, if available.  </td><td>Ignored by <code>aiProcess_RemoveRedundantMaterials</code>. Materials are considered equal even if their names are different.  </td></tr>
<tr>
<td><code>COLOR_DIFFUSE</code> </td><td><a class="el" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space.">aiColor3D</a> </td><td>black (0,0,0) </td><td>Diffuse color of the material. This is typically scaled by the amount of incoming diffuse light (e.g. using gouraud shading)  </td><td>---  </td></tr>
<tr>
<td><code>COLOR_SPECULAR</code> </td><td><a class="el" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space.">aiColor3D</a> </td><td>black (0,0,0) </td><td>Specular color of the material. This is typically scaled by the amount of incoming specular light (e.g. using phong shading)  </td><td>---  </td></tr>
<tr>
<td><code>COLOR_AMBIENT</code> </td><td><a class="el" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space.">aiColor3D</a> </td><td>black (0,0,0) </td><td>Ambient color of the material. This is typically scaled by the amount of ambient light  </td><td>---  </td></tr>
<tr>
<td><code>COLOR_EMISSIVE</code> </td><td><a class="el" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space.">aiColor3D</a> </td><td>black (0,0,0) </td><td>Emissive color of the material. This is the amount of light emitted by the object. In real time applications it will usually not affect surrounding objects, but raytracing applications may wish to treat emissive objects as light sources.  </td><td>--- <p>
</td></tr>
<tr>
<td><code>COLOR_TRANSPARENT</code> </td><td><a class="el" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space.">aiColor3D</a> </td><td>black (0,0,0) </td><td>Defines the transparent color of the material, this is the color to be multiplied with the color of translucent light to construct the final 'destination color' for a particular position in the screen buffer. T  </td><td>--- <p>
</td></tr>
<tr>
<td><code>WIREFRAME</code> </td><td>int </td><td>false </td><td>Specifies whether wireframe rendering must be turned on for the material. 0 for false, !0 for true.  </td><td>--- <p>
</td></tr>
<tr>
<td><code>TWOSIDED</code> </td><td>int </td><td>false </td><td>Specifies whether meshes using this material must be rendered without backface culling. 0 for false, !0 for true.  </td><td>Some importers set this property if they don't know whether the output face oder is right. As long as it is not set, you may safely enable backface culling. <p>
</td></tr>
<tr>
<td><code>SHADING_MODEL</code> </td><td>int </td><td>gouraud </td><td>One of the <a class="el" href="ai_material_8h.html#93e23e0201d6ed86fb4287e15218e4cf" title="Defines all shading models supported by the library.">aiShadingMode</a> enumerated values. Defines the library shading model to use for (real time) rendering to approximate the original look of the material as closely as possible.  </td><td>The presence of this key might indicate a more complex material. If absent, assume phong shading only if a specular exponent is given. <p>
</td></tr>
<tr>
<td><code>BLEND_FUNC</code> </td><td>int </td><td>false </td><td>One of the <a class="el" href="ai_material_8h.html#e1236da1ccfbf4f23bb490287a4d61ac" title="Defines alpha-blend flags.">aiBlendMode</a> enumerated values. Defines how the final color value in the screen buffer is computed from the given color at that position and the newly computed color from the material. Simply said, alpha blending settings. </td><td>- <p>
</td></tr>
<tr>
<td><code>OPACITY</code> </td><td>float </td><td>1.0 </td><td>Defines the opacity of the material in a range between 0..1. </td><td>Use this value to decide whether you have to activate alpha blending for rendering. <code>OPACITY</code> != 1 usually also implies TWOSIDED=1 to avoid cull artifacts. <p>
</td></tr>
<tr>
<td><code>SHININESS</code> </td><td>float </td><td>0.f </td><td>Defines the shininess of a phong-shaded material. This is actually the exponent of the phong specular equation </td><td><code>SHININESS</code>=0 is equivalent to <code>SHADING_MODEL</code>=<code>aiShadingMode_Gouraud</code>. <p>
</td></tr>
<tr>
<td><code>SHININESS_STRENGTH</code> </td><td>float </td><td>1.0 </td><td>Scales the specular color of the material. </td><td>This value is kept separate from the specular color by most modelers, and so do we. <p>
</td></tr>
<tr>
<td><code>REFRACTI</code> </td><td>float </td><td>1.0 </td><td>Defines the Index Of Refraction for the material. That's not supported by most file formats. </td><td>Might be of interest for raytracing. <p>
</td></tr>
<tr>
<td><code>TEXTURE(t,n)</code> </td><td><a class="el" href="structai_string.html" title="Represents an UTF-8 string, zero byte terminated.">aiString</a> </td><td>n/a </td><td>Defines the path to the n'th texture on the stack 't', where 'n' is any value &gt;= 0 and 't' is one of the <a class="el" href="ai_material_8h.html#7dd415ff703a2cc53d1c22ddbbd7dde0" title="Defines the purpose of a texture.">aiTextureType</a> enumerated values. </td><td>See the 'Textures' section above. <p>
</td></tr>
<tr>
<td><code>TEXBLEND(t,n)</code> </td><td>float </td><td>n/a </td><td>Defines the strength the n'th texture on the stack 't'. All color components (rgb) are multipled with this factor *before* any further processing is done. </td><td>- <p>
</td></tr>
<tr>
<td><code>TEXOP(t,n)</code> </td><td>int </td><td>n/a </td><td>One of the <a class="el" href="ai_material_8h.html#fcd3096d69affba13114cedfc6f9ee6b" title="Defines how the Nth texture of a specific type is combined with the result of all...">aiTextureOp</a> enumerated values. Defines the arithmetic operation to be used to combine the n'th texture on the stack 't' with the n-1'th. <code>TEXOP(t,0)</code> refers to the blend operation between the base color for this stack (e.g. <code>COLOR_DIFFUSE</code> for the diffuse stack) and the first texture. </td><td>- <p>
</td></tr>
<tr>
<td><code>MAPPING(t,n)</code> </td><td>int </td><td>n/a </td><td>Defines how the input mapping coordinates for sampling the n'th texture on the stack 't' are computed. Usually explicit UV coordinates are provided, but some model file formats might also be using basic shapes, such as spheres or cylinders, to project textures onto meshes. </td><td>See the 'Textures' section below. <a class="el" href="ai_post_process_8h.html#64795260b95f5a4b3f3dc1be4f52e410a4ae05f45c5682ab245cf8e87986426f">aiProcess_GenUVCoords</a> can be used to let <a class="el" href="namespace_assimp.html" title="Assimp&#39;s CPP-API and all internal APIs.">Assimp</a> compute proper UV coordinates from projective mappings. <p>
</td></tr>
<tr>
<td><code>UVWSRC(t,n)</code> </td><td>int </td><td>n/a </td><td>Defines the UV channel to be used as input mapping coordinates for sampling the n'th texture on the stack 't'. All meshes assigned to this material share the same UV channel setup </td><td>Presence of this key implies <code>MAPPING(t,n)</code> to be <a class="el" href="ai_material_8h.html#6186e909f1ae28133ab10f1b4635b0f9fe4af8e2f0303198ff2c51edf3039277" title="The mapping coordinates are taken from an UV channel.">aiTextureMapping_UV</a>. See <a class="el" href="materials.html#uvwsrc">How to map UV channels to textures (MATKEY_UVWSRC)</a> for more details.  <p>
</td></tr>
<tr>
<td><code>MAPPINGMODE_U(t,n)</code> </td><td>int </td><td>n/a </td><td>Any of the <a class="el" href="ai_material_8h.html#6cbe56056751aa80e8dd714632a49de0" title="Defines how UV coordinates outside the [0.">aiTextureMapMode</a> enumerated values. Defines the texture wrapping mode on the x axis for sampling the n'th texture on the stack 't'. 'Wrapping' occurs whenever UVs lie outside the 0..1 range.  </td><td>- <p>
</td></tr>
<tr>
<td><code>MAPPINGMODE_V(t,n)</code> </td><td>int </td><td>n/a </td><td>Wrap mode on the v axis. See <code>MAPPINGMODE_U</code>.  </td><td>- <p>
</td></tr>
<tr>
<td><code>TEXMAP_AXIS(t,n)</code> </td><td><a class="el" href="structai_vector3_d.html" title="Represents a three-dimensional vector.">aiVector3D</a> </td><td>n/a </td><td>Defines the base axis to to compute the mapping coordinates for the n'th texture on the stack 't' from. This is not required for UV-mapped textures. For instance, if <code>MAPPING(t,n)</code> is <a class="el" href="ai_material_8h.html#6186e909f1ae28133ab10f1b4635b0f9da83cfca5e55fc99dc89e0e94c91cdb5" title="Spherical mapping.">aiTextureMapping_SPHERE</a>, U and V would map to longitude and latitude of a sphere around the given axis. The axis is given in local mesh space. </td><td>- <p>
</td></tr>
<tr>
<td><code>TEXFLAGS(t,n)</code> </td><td>int </td><td>n/a </td><td>Defines miscellaneous flag for the n'th texture on the stack 't'. This is a bitwise combination of the <a class="el" href="ai_material_8h.html#6d003e078617e4e80d1313a6250b2dfd" title="Defines some mixed flags for a particular texture.">aiTextureFlags</a> enumerated values. </td><td>- <p>
</td></tr>
</table>
<h2><a class="anchor" name="cpp">
C++-API</a></h2>
Retrieving a property from a material is done using various utility functions. For C++ it's simply calling <a class="el" href="structai_material.html#c180af3603e27b474aec08468e09276e" title="Retrieve an array of Type values with a specific key from the material.">aiMaterial::Get()</a><p>
<div class="fragment"><pre class="fragment"><a class="code" href="structai_material.html" title="Data structure for a material.">aiMaterial</a>* mat = .....

<span class="comment">// The generic way</span>
if(AI_SUCCESS != mat-&gt;<a class="code" href="structai_material.html#c180af3603e27b474aec08468e09276e" title="Retrieve an array of Type values with a specific key from the material.">Get</a>(&lt;material-key&gt;,&lt;where-to-store&gt;)) {
   <span class="comment">// handle epic failure here</span>
}
</pre></div><p>
Simple, isn't it? To get the name of a material you would use<p>
<div class="fragment"><pre class="fragment"><a class="code" href="structai_string.html" title="Represents an UTF-8 string, zero byte terminated.">aiString</a> name;
mat-&gt;<a class="code" href="structai_material.html#c180af3603e27b474aec08468e09276e" title="Retrieve an array of Type values with a specific key from the material.">Get</a>(AI_MATKEY_NAME,name);
</pre></div><p>
Or for the diffuse color ('color' won't be modified if the property is not set)<p>
<div class="fragment"><pre class="fragment"><a class="code" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space.">aiColor3D</a> color (0.f,0.f,0.f);
mat-&gt;<a class="code" href="structai_material.html#c180af3603e27b474aec08468e09276e" title="Retrieve an array of Type values with a specific key from the material.">Get</a>(AI_MATKEY_COLOR_DIFFUSE,color);
</pre></div><p>
<b>Note:</b> Get() is actually a template with explicit specializations for <a class="el" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space.">aiColor3D</a>, <a class="el" href="structai_color4_d.html" title="Represents a color in Red-Green-Blue space including an alpha component.">aiColor4D</a>, <a class="el" href="structai_string.html" title="Represents an UTF-8 string, zero byte terminated.">aiString</a>, float, int and some others. Make sure that the type of the second parameter is matching the expected data type of the material property (no compile-time check yet!). Don't follow this advice if you wish to encounter very strange results.<h2><a class="anchor" name="C">
C-API</a></h2>
For good old C it's slightly different. Take a look at the aiGetMaterialGet&lt;data-type&gt; functions.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="structai_material.html" title="Data structure for a material.">aiMaterial</a>* mat = .....

if(AI_SUCCESS != aiGetMaterialFloat(mat,&lt;material-key&gt;,&lt;where-to-store&gt;)) {
   <span class="comment">// handle epic failure here</span>
}
</pre></div><p>
To get the name of a material you would use<p>
<div class="fragment"><pre class="fragment"><a class="code" href="structai_string.html" title="Represents an UTF-8 string, zero byte terminated.">aiString</a> name;
aiGetMaterialString(mat,AI_MATKEY_NAME,&amp;name);
</pre></div><p>
Or for the diffuse color ('color' won't be modified if the property is not set)<p>
<div class="fragment"><pre class="fragment"><a class="code" href="structai_color3_d.html" title="Represents a color in Red-Green-Blue space.">aiColor3D</a> color (0.f,0.f,0.f);
aiGetMaterialColor(mat,AI_MATKEY_COLOR_DIFFUSE,&amp;color);
</pre></div><h2><a class="anchor" name="uvwsrc">
How to map UV channels to textures (MATKEY_UVWSRC)</a></h2>
The MATKEY_UVWSRC property is only present if the source format doesn't specify an explicit mapping from textures to UV channels. Many formats don't do this and ASSIMP is not aware of a perfect rule either.<p>
Your handling of UV channels needs to be flexible therefore. Our recommendation is to use logic like this to handle most cases properly:<p>
<div class="fragment"><pre class="fragment">
have only one uv channel?
   assign channel 0 to all textures and break

for all textures
   have uvwsrc for this texture?
      assign channel specified in uvwsrc
   else
      assign channels in ascending order for all texture stacks, 
	    i.e. diffuse1 gets channel 1, opacity0 gets channel 0.

</pre></div><h2><a class="anchor" name="pseudo">
Pseudo Code Listing</a></h2>
For completeness, the following is a very rough pseudo-code sample showing how to evaluate <a class="el" href="namespace_assimp.html" title="Assimp&#39;s CPP-API and all internal APIs.">Assimp</a> materials in your shading pipeline. You'll probably want to limit your handling of all those material keys to a reasonable subset suitable for your purposes (for example most 3d engines won't support highly complex multi-layer materials, but many 3d modellers do).<p>
Also note that this sample is targeted at a (shader-based) rendering pipeline for real time graphics.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// ---------------------------------------------------------------------------------------</span>
<span class="comment">// Evaluate multiple textures stacked on top of each other</span>
float3 EvaluateStack(stack)
{
  <span class="comment">// For the 'diffuse' stack stack.base_color would be COLOR_DIFFUSE</span>
  <span class="comment">// and TEXTURE(aiTextureType_DIFFUSE,n) the n'th texture.</span>

  float3 base = stack.base_color;
  <span class="keywordflow">for</span> (every texture in stack)
  {
    <span class="comment">// assuming we have explicit &amp; pretransformed UVs for this texture</span>
    float3 color = SampleTexture(texture,uv); 

    <span class="comment">// scale by texture blend factor</span>
    color *= texture.blend;

    <span class="keywordflow">if</span> (texture.op == <span class="keyword">add</span>)
      base += color;
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (texture.op == multiply)
      base *= color;
    <span class="keywordflow">else</span> <span class="comment">// other blend ops go here</span>
  }
  <span class="keywordflow">return</span> base;
}

<span class="comment">// ---------------------------------------------------------------------------------------</span>
<span class="comment">// Compute the diffuse contribution for a pixel</span>
float3 ComputeDiffuseContribution()
{
  <span class="keywordflow">if</span> (shading == none)
     <span class="keywordflow">return</span> float3(1,1,1);

  float3 intensity (0,0,0);
  <span class="keywordflow">for</span> (all lights in range)
  {
    <span class="keywordtype">float</span> fac = 1.f;
    <span class="keywordflow">if</span> (shading == gouraud)
      fac =  lambert-term ..
    <span class="keywordflow">else</span> <span class="comment">// other shading modes go here</span>

    <span class="comment">// handling of different types of lights, such as point or spot lights</span>
    <span class="comment">// ...</span>

    <span class="comment">// and finally sum the contribution of this single light ...</span>
    intensity += light.diffuse_color * fac;
  }
  <span class="comment">// ... and combine the final incoming light with the diffuse color</span>
  <span class="keywordflow">return</span> EvaluateStack(diffuse) * intensity;
}

<span class="comment">// ---------------------------------------------------------------------------------------</span>
<span class="comment">// Compute the specular contribution for a pixel</span>
float3 ComputeSpecularContribution()
{
  <span class="keywordflow">if</span> (shading == gouraud || specular_strength == 0 || specular_exponent == 0)
    <span class="keywordflow">return</span> float3(0,0,0);

  float3 intensity (0,0,0);
  <span class="keywordflow">for</span> (all lights in range)
  {
    <span class="keywordtype">float</span> fac = 1.f;
    <span class="keywordflow">if</span> (shading == phong)
      fac =  phong-term ..
    <span class="keywordflow">else</span> <span class="comment">// other specular shading modes go here</span>

    <span class="comment">// handling of different types of lights, such as point or spot lights</span>
    <span class="comment">// ...</span>

    <span class="comment">// and finally sum the specular contribution of this single light ...</span>
    intensity += light.specular_color * fac;
  }
  <span class="comment">// ... and combine the final specular light with the specular color</span>
  <span class="keywordflow">return</span> EvaluateStack(specular) * intensity * specular_strength;
}

<span class="comment">// ---------------------------------------------------------------------------------------</span>
<span class="comment">// Compute the ambient contribution for a pixel</span>
float3 ComputeAmbientContribution()
{
  <span class="keywordflow">if</span> (shading == none)
     <span class="keywordflow">return</span> float3(0,0,0);

  float3 intensity (0,0,0);
  <span class="keywordflow">for</span> (all lights in range)
  {
    <span class="keywordtype">float</span> fac = 1.f;

    <span class="comment">// handling of different types of lights, such as point or spot lights</span>
    <span class="comment">// ...</span>

    <span class="comment">// and finally sum the ambient contribution of this single light ...</span>
    intensity += light.ambient_color * fac;
  }
  <span class="comment">// ... and combine the final ambient light with the ambient color</span>
  <span class="keywordflow">return</span> EvaluateStack(ambient) * intensity;
}

<span class="comment">// ---------------------------------------------------------------------------------------</span>
<span class="comment">// Compute the final color value for a pixel</span>
<span class="comment">// @param prev Previous color at that position in the framebuffer</span>
float4 PimpMyPixel (float4 prev)
{
  <span class="comment">// .. handle displacement mapping per vertex</span>
  <span class="comment">// .. handle bump/normal mapping</span>

  <span class="comment">// Get all single light contribution terms</span>
  float3 diff = ComputeDiffuseContribution();
  float3 spec = ComputeSpecularContribution(); 
  float3 ambi = ComputeAmbientContribution();

  <span class="comment">// .. and compute the final color value for this pixel</span>
  float3 color = diff + spec + ambi;
  float3 opac  = EvaluateStack(opacity);

  <span class="comment">// note the *slightly* strange meaning of additive and multiplicative blending here ...</span>
  <span class="comment">// those names will most likely be changed in future versions</span>
  <span class="keywordflow">if</span> (blend_func == <span class="keyword">add</span>)
       <span class="keywordflow">return</span> prev+color*opac;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (blend_func == multiply)
       <span class="keywordflow">return</span> prev*(1.0-opac)+prev*opac;

   <span class="keywordflow">return</span> color;
}
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 17 18:41:24 2010 for Assimp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
